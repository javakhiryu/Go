package main

import (
	"os"
	"os/exec"
	"syscall"
)

func main(){
	// Ищем полный путь к бинарному файлу 'ls' в системном пути.
	binary, lookErr := exec.LookPath("ls")
	if lookErr !=nil{
		panic(lookErr)
	}

	// Аргументы для команды 'ls'.
	//Здесь мы определяем аргументы, которые будут переданы команде ls. В данном случае: -a (показать все файлы, включая скрытые), -l (подробный формат) и -h (человекочитаемый формат размеров файлов).
	args := []string{"ls", "-a", "-l", "-h"}

	// Получаем текущие переменные окружения.
	//Функция os.Environ возвращает копию списка переменных окружения текущего процесса в формате []string.
	env :=os.Environ()

	// Выполняем команду 'ls' с использованием системного вызова Exec.
	//Функция syscall.Exec заменяет текущий процесс новым процессом, выполняющим указанную команду. В данном случае это ls с аргументами -a -l -h. Если выполнение завершается с ошибкой, программа завершится с паникой.
	execErr :=syscall.Exec(binary, args, env)
	if execErr != nil {
		panic(execErr)
	}
}

//Системный вызов syscall.Exec в Go используется для выполнения новой программы, заменяя текущий процесс. Этот вызов доступен только на операционных системах, поддерживающих системные вызовы, совместимые с Unix, таких как:
//
//Linux
//macOS
//BSD (FreeBSD, OpenBSD, NetBSD)
//Solaris

//Альтернативы для Windows
//Для выполнения внешних команд на Windows, можно использовать exec.Command и связанные методы, которые предоставляют аналогичный функционал, хотя и с некоторыми отличиями. Например:

package main

import (
    "fmt"
    "os/exec"
)

func main() {

    // Создание команды 'dir' (аналог 'ls' на Windows).
    cmd := exec.Command("cmd", "/C", "dir")

    // Выполнение команды и получение вывода.
    output, err := cmd.Output()
    if err != nil {
        panic(err)
    }

    // Печать вывода команды.
    fmt.Println(string(output))
}
