// Этот пример демонстрирует использование канала и функции select в Go для реализации тайм-аута при ожидании завершения горутины. Код создает горутину, которая отправляет значение в канал через 2 секунды, и использует select для выбора между получением значения из канала и тайм-аутом через 3 секунды.
package main

import (
	"fmt"
	"time"
)

func main() {
	// Создание канала с буфером размером 1
	c1 := make(chan string, 1)

	// Запуск горутины, которая спит 2 секунды, затем отправляет значение в канал
	go func() {
		time.Sleep(2 * time.Second)
		c1 <- "result 1"
	}()

	// Использование select для ожидания либо получения значения из канала, либо тайм-аута
	select {
	case res := <-c1:
		// Этот случай выполнится, если значение было получено из канала до истечения тайм-аута
		fmt.Println(res)

	case <-time.After(3 * time.Second):
		// Этот случай выполнится, если истечет 3 секунды до получения значения из канала
		fmt.Println("timeout")
	}
}

//Этот пример показывает, как можно использовать select и time.After для реализации тайм-аута при ожидании выполнения горутины. Это полезная техника для предотвращения блокировки программы в случае, если горутина занимает слишком много времени для выполнения своей задачи.
