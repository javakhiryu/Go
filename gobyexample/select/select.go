//Ваш код демонстрирует использование оператора select для ожидания сообщений из нескольких каналов. Две горутины отправляют сообщения в каналы c1 и c2 после задержки в 5 и 10 секунд соответственно. В главной функции используется select для обработки сообщений из этих каналов.

package main

import (
	"fmt"
	"time"
)

func main() {
	// Создаем два канала
	c1 := make(chan string)
	c2 := make(chan string)

	// Горутина для отправки сообщения в c1 после 5 секунд
	go func() {
		time.Sleep(5 * time.Second)
		c1 <- "one"
	}()

	// Горутина для отправки сообщения в c2 после 10 секунд
	go func() {
		time.Sleep(10 * time.Second)
		c2 <- "two"
	}()

	// Используем select для ожидания сообщений из каналов c1 и c2
	for i := 0; i < 2; i++ {
		select {
		case msg1 := <-c1:
			fmt.Println("recieved:", msg1)

		case msg2 := <-c2:
			fmt.Println("recieved:", msg2)
		}
	}
}

//Объяснение:
//
//Создание каналов: Создаются два канала c1 и c2 для передачи строк.
//Первая горутина: Эта горутина вызывает time.Sleep(5 * time.Second), чтобы приостановить выполнение на 5 секунд, а затем отправляет строку "one" в канал c1.
//Вторая горутина: Эта горутина вызывает time.Sleep(10 * time.Second), чтобы приостановить выполнение на 10 секунд, а затем отправляет строку "two" в канал c2.
//Цикл for с select: В цикле for, который выполняется два раза, оператор select используется для ожидания сообщений из каналов c1 и c2. Когда сообщение доступно в одном из каналов, соответствующий случай выполняется и сообщение выводится на экран.
//Если сообщение поступает из c1, выводится "received: one".
//Если сообщение поступает из c2, выводится "received: two".
//
//Поскольку select блокирует выполнение до тех пор, пока одно из условий не выполнится, программа сначала выведет сообщение из c1 (через 5 секунд), а затем сообщение из c2 (через 10 секунд).
