//Этот пример демонстрирует использование time.Ticker в Go для периодического выполнения кода через заданные интервалы времени. Тикер запускает горутину, которая печатает время тика каждые 500 миллисекунд, пока не будет остановлена.

package main

import (
	"fmt"
	"time"
)

func main() {

	// Создание нового тикера, который будет тикать каждые 500 миллисекунд
	ticker := time.NewTicker(500 * time.Millisecond)

	// Канал для завершения работы горутины
	done := make(chan bool)

	// Запуск горутины, которая обрабатывает тики тикера
	go func() {
		for {
			select {
			case <-done:
				// Завершение работы горутины, если получено значение из канала done
				return
			case t := <-ticker.C:
				// Обработка тика тикера
				fmt.Println("Tick at", t)
			}
		}
	}()

	// Основная горутина спит 1600 миллисекунд
	time.Sleep(1600 * time.Millisecond)

	// Остановка тикера
	ticker.Stop()

	// Отправка сигнала завершения в канал done
	done <- true

	// Печать сообщения о том, что тикер остановлен
	fmt.Println("Ticker stopped")
}

//Этот пример показывает, как использовать time.Ticker для периодического выполнения кода и как управлять завершением работы горутины с помощью каналов. Тикеры полезны для задач, которые требуют регулярного выполнения через определенные интервалы времени, такие как обновление данных, мониторинг состояния или выполнение повторяющихся действий.
